/* eslint-disable @typescript-eslint/no-var-requires */
const gm = require('gm');
const gulp = require('gulp');
const webp = require('gulp-webp');
const path = require('path');
const through = require('through2');

const _gm = gm.subClass({ imageMagick: true });

gulp.task('webp-service', () => {
  return gulp
    .src('./tmp/service/**/*.{gif,png,jpg}')
    .pipe(
      through.obj(function (originalFile, enc, cb) {
        if (originalFile.isNull()) {
          return cb(null, originalFile);
        }
        if (originalFile.isStream()) {
          return cb(new Error('Streaming not supported'));
        }
        const file = originalFile.clone({ contents: false });
        const gmFile = _gm(file.contents, file.path);
        gmFile.size((err, size) => {
          if (err) {
            return cb(new Error(err));
          }
          const extname = path.extname(file.path);
          file.path = path.join(
            path.dirname(file.path),
            `${path.basename(file.path, extname)}@600w${extname}`,
          );
          const height = Math.ceil((600 / size.width) * size.height);
          gmFile.resize(600, height).toBuffer((err, buffer) => {
            if (err) {
              return cb(new Error(err));
            }
            file.contents = buffer;
            cb(null, file);
          });
        });
      }),
    )
    .pipe(webp())
    .pipe(gulp.dest('./assets/images/service/'));
});

gulp.task('webp-header', () => {
  const sizes = [600, 960, 1280, 1920];
  const tsFileContents = {};
  let lastFile;

  return gulp
    .src('./tmp/images/**/*.{gif,png,jpg}')
    .pipe(
      through.obj(function (originalFile, enc, cb) {
        if (originalFile.isNull()) {
          return cb(null, file);
        }
        if (originalFile.isStream()) {
          return cb(new Error('Streaming not supported'));
        }
        const orgGmFile = _gm(originalFile.contents, originalFile.path);
        new Promise((resolve) => {
          orgGmFile.size((err, size) => {
            if (err) {
              return cb(new Error(err));
            }
            resolve(size);
          });
        })
          .then((size) => {
            const ratio = size.width / size.height;
            const filePath = path
              .relative(originalFile.base, originalFile.path)
              .replace('\\', '/');
            const fileset = filePath.slice(0, filePath.indexOf('.'));
            if (tsFileContents[fileset] === undefined) {
              tsFileContents[fileset] = {
                imports: [],
                exports: [],
                ratio,
              };
            }
            const promises = sizes.map((width) => {
              const file = originalFile.clone({ contents: false });
              const extname = path.extname(file.path);
              file.path = path.join(
                path.dirname(file.path),
                `${path.basename(file.path, extname)}@${width}w${extname}`,
              );
              const gmFile = _gm(file.contents, file.path);
              const height = Math.ceil((width / size.width) * size.height);
              return new Promise((resolve) => {
                gmFile.resize(width, height).toBuffer((err, buffer) => {
                  if (err) {
                    return cb(new Error(err));
                  }
                  file.contents = buffer;
                  this.push(file);
                  resolve();
                });
              });
            });
            return Promise.all(promises);
          })
          .then(() => {
            cb();
          });
      }),
    )
    .pipe(webp())
    .pipe(gulp.dest('./assets/images/'))
    .pipe(
      through.obj(
        function (file, enc, cb) {
          if (file.isNull()) {
            return cb(null, file);
          }
          if (file.isStream()) {
            return cb(new Error('Streaming not supported'));
          }
          const filePath = path
            .relative(file.base, file.path)
            .replace('\\', '/');
          const fileset = filePath.slice(0, filePath.indexOf('@'));
          const size = filePath.match(/@(\d+)w/)[1];
          tsFileContents[fileset].imports.push(
            `import src${size}w from '~/assets/images/${filePath}';`,
          );
          tsFileContents[fileset].exports.push(`  src${size}w,`);
          lastFile = file;
          cb();
        },
        function (cb) {
          Object.entries(tsFileContents).forEach(([key, val]) => {
            const tsFile = lastFile.clone({ contents: false });
            tsFile.path = path.join(lastFile.base, key + '.ts');
            const contents = [
              '// generated by yarn generate:webp',
              val.imports.join('\n'),
              `\nconst images = {`,
              val.exports.join('\n'),
              `  aspectRatio: ${val.ratio},`,
              '};\n',
              `export default images;\n`,
            ].join('\n');
            const buffer = Buffer.alloc(contents.length);
            buffer.write(contents);
            tsFile.contents = buffer;
            this.push(tsFile);
          });
          cb();
        },
      ),
    )
    .pipe(gulp.dest('./hooks/images/'));
});

gulp.task('default', gulp.series('webp-service', 'webp-header'));
